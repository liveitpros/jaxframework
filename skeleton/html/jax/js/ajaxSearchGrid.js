// DO NOT EDIT THIS FILE.
// This file is part of the Jax Framework.
// If you edit this file, your changes will be lost when framework updates are applied.

// Copyright (c) 2014-2015 Ronald B. Cemer
// All rights reserved.
// This software is released under the BSD license.
// Please see the accompanying LICENSE.txt for details.

// Constructor function.
// Function arguments:
// container: A jQuery instance or CSS selector representing the element which contains
//   the table.  It should reference an element like this:
//       <div id="mySeachGrid" ng-app="JaxGridApp" ng-controller="Controller"></div>
//   It may or may not already contain the pagers and table, with thead element (including
//   full   column headings) and tbody element (including ng-repeat for rows, and columns
//   within the rows).  If tableHTML is passed in and is a non-empty string, the
//   entire contents of this div will be replaced with the tableHTML, plus one pager
//   element above and one pager element below.
// params: An object which maps parameter names to their values.  Acceptable parameters:
//   searchCommand: The value of the "command" query string parameter when making the
//     HTTP request to the server for the JSON-encoded data.
//     Example: 'searchEmployees'
//     Required.
//   columnNames: An array of string column names to be returned from the server.
//     Example: ['id', 'first_name', 'last_name']
//     Required.
//   defaultSorts: An array of objects to control the initial sort direction, where each
//     object has an attr attribute which contains the name of the sort column, and dir
//     attribute which controls the sort direction (1 for ascending; -1 for descending).
//     Example: [{attr:'last_name', dir:1}, {attr:'first_name', dir:1}]
//     Optional.  Defaults to whatever the default sort order is on the server side.
//   columnFilters: An optional object whose keys map filter function names to
//     filter functions.  Each function takes the following arguments:
//       val: The unfiltered column value, with any previous filter functions applied.
//       row: The row object.
//       rowIdx: The index of the row, relative to the current page of results.
//   extraQueryParams: An optional object which maps parameter names to parameter values
//     for the query string.  These extra parameters will be appended to the AJAX request
//     URL before each search.  Parameter names and values must NOT be URL-encoded in this
//     map; encodeURIComponent() will be called on them automatically as they are appended
//     to the AJAX request URL.  If any of the keys match existing query parameters on
//     the search URL, their existing values will be replaced with the values from this
//     map.
//   beforeSearchCallback: An optional function to be called at the beginning of each
//     search.  The function receives the AJAXSearchGrid as its only argument.
//
//     The searchBeginDate attribute of the AJAXSearchGrid.$scope instance will be set
//     to a Date instance which contains the date/time when the search began (immediately
//     before beforeSearchCallback was called).
//     The searchEndDate attribute of the AJAXSearchGrid.$scope instance will be null.
//   modifyURLCallback: An optional function to modify the server-side request URL before
//     making the server-side request.  The function receives the AJAXSearchGrid and the
//     URL as its arguments, and returns the modified URL.  The function will get called
//     once for each server-side search request.
//     Optional.
//   afterSearchCallback: An optional function to be called at the end of each
//     search.  The function receives the AJAXSearchGrid as its only argument.
//
//     The searchBeginDate attribute of the AJAXSearchGrid.$scope instance will be set
//     to a Date instance which contains the date/time when the search began (immediately
//     before beforeSearchCallback was called).
//     The searchEndDate attribute of the AJAXSearchGrid.$scope instance will be set
//     to a Date instance which contains the date/time when the search began (immediately
//     before afterSearchCallback was called).
//   tableHTML: An optional argument containing HTML text with AngularJS tags embedded, to
//     build the search table.  If this is present and is not empty, the contents of the
//     container element will be replaced with this HTML, plus a pager element above and a
//     pager element below the table HTML.
//   enableKeyboardNavigation: true to enable up/down arrow keys and PageUp/PageDown navigation
//     using the keyboard.  This also enables mouse clicking on a row to highlight that row,
//     and double-clicking on a row to simulate pressing the Enter key with that row highlighted.
//     The Enter key is typically used to invoke the default action for a row.
//     Optional.  Defaults to true.
//   hotKeyActionMap: an array of objects, where each object contains the scan code, alt key
//     status, control key status, shift key status, and meta key status for a hot key, along
//     with a callback function to be called when the hot key combination is pressed.
//     Each object in the array should contain the following attributes:
//         which: The scan code of the hot key.  Matches EventObject.which.  Required.
//         altKey: true if the Alt key must be held down, false if not.  Optional.  Defaults to false.
//         ctrlKey: true if the Ctrl key must be held down, false if not.  Optional.  Defaults to false.
//         shiftKey: true if the Shift key must be held down, false if not.  Optional.  Defaults to false.
//         metaKey: true if the Meta key must be held down, false if not.  Optional.  Defaults to false.
//                  NOTE: This corresponds to the Command key on Macintosh, or the Windows key on a PC.
//         callback: a function which receives the following arguments:
//             ajaxGrid: The AJAXSearchGrid which triggered the callback.
//             evt: The EventObject instance for the event.
function AJAXSearchGrid(container, params, tableHTML) {
	if (typeof(container) == 'string') container = $(container);
	if ((typeof(tableHTML) != 'undefined') && (tableHTML != '')) {
		container.html(
			"\n\n"+'<div class="jax-grid-pager" has-search-box has-search-by></div>'+"\n\n"+
			tableHTML+"\n\n"+
			'<div class="jax-grid-pager" has-search-box has-search-by></div>'+"\n\n"
		);
	}

	this.$scope = angular.element(container).scope();

	this.defaultSorts = (typeof(params.defaultSorts) != 'undefined') ? params.defaultSorts : [];

	this.$scope.columnFilters = {
		intToYesNo:function(val, row, rowIdx) {
			return _t(((parseInt(val) || 0) != 0) ? 'system.yes' : 'system.no');
		}
		,numscale0:function(val, row, rowIdx) {
			var num = Number(val);
			if (isNaN(num)) num = 0.0;
			return num.toFixed(0);
		}
		,numscale1:function(val, row, rowIdx) {
			var num = Number(val);
			if (isNaN(num)) num = 0.0;
			return num.toFixed(1);
		}
		,numscale2:function(val, row, rowIdx) {
			var num = Number(val);
			if (isNaN(num)) num = 0.0;
			return num.toFixed(2);
		}
		,numscale3:function(val, row, rowIdx) {
			var num = Number(val);
			if (isNaN(num)) num = 0.0;
			return num.toFixed(3);
		}
		,numscale4:function(val, row, rowIdx) {
			var num = Number(val);
			if (isNaN(num)) num = 0.0;
			return num.toFixed(4);
		}
		,numscale5:function(val, row, rowIdx) {
			var num = Number(val);
			if (isNaN(num)) num = 0.0;
			return num.toFixed(5);
		}
		,numscale6:function(val, row, rowIdx) {
			var num = Number(val);
			if (isNaN(num)) num = 0.0;
			return num.toFixed(6);
		}
		,numscale7:function(val, row, rowIdx) {
			var num = Number(val);
			if (isNaN(num)) num = 0.0;
			return num.toFixed(7);
		}
		,numscale8:function(val, row, rowIdx) {
			var num = Number(val);
			if (isNaN(num)) num = 0.0;
			return num.toFixed(8);
		}
		,numscale9:function(val, row, rowIdx) {
			var num = Number(val);
			if (isNaN(num)) num = 0.0;
			return num.toFixed(9);
		}
		,numscale10:function(val, row, rowIdx) {
			var num = Number(val);
			if (isNaN(num)) num = 0.0;
			return num.toFixed(10);
		}
	}
	if (typeof(params.columnFilters) == 'object') {
		for (var filterName in params.columnFilters) {
			this.$scope.columnFilters[filterName] = params.columnFilters[filterName];
		}
	}

	this.extraQueryParams = (typeof(params.extraQueryParams) == 'object') ? params.extraQueryParams : {};

	this.$scope.externalPager = true;

	this.searchCommand = params.searchCommand;
	this.columnNames = params.columnNames;

	this.beforeSearchCallback = (typeof(params.beforeSearchCallback) == 'function') ?
		params.beforeSearchCallback : null;

	this.modifyURLCallback = (typeof(params.modifyURLCallback) == 'function') ?
		params.modifyURLCallback : null;

	this.afterSearchCallback = (typeof(params.afterSearchCallback) == 'function') ?
		params.afterSearchCallback : null;

	this.enableKeyboardNavigation = (typeof(params.enableKeyboardNavigation) == 'boolean') ? params.enableKeyboardNavigation : true;

	this.hotKeyActionMap = ((typeof(params.hotKeyActionMap) != 'undefined') && (params.hotKeyActionMap instanceof Array)) ? params.hotKeyActionMap : [];

	this.rowFetcher = new RowFetcher();
	this.baseURL = this.rowFetcher.getBaseURL();

	// Fetch searchable columns; populate this.$scope.searchByOptions.
	var url = this.baseURL+'?command='+encodeURIComponent(this.searchCommand+'_getSearchableColumns');
	if (typeof fixupAJAXURL == 'function') {
		url = fixupAJAXURL(url);
	}
	this.searchableColumns = this.rowFetcher.getRowArrayForURL(url);
	var searchByOptions = [];
	for (var i = 0; i < this.searchableColumns.length; i++) {
		searchByOptions.push({
			searchBy:this.searchableColumns[i].pfx+this.searchableColumns[i].name,
			description:this.searchableColumns[i].title
		});
	}
	this.$scope.searchByOptions = searchByOptions;

	this.$scope.searchBeginDate = null;
	this.$scope.searchEndDate = null;

	this.$scope.searchCallbackThis = this;
	this.$scope.searchCallback = function() {
		this.$scope.searchBeginDate = new Date();
		this.$scope.searchEndDate = null;
		if (this.beforeSearchCallback !== null) {
			this.beforeSearchCallback(this);
		}

		var paramsMap = {
			command:this.searchCommand
			,sSearch:$.trim(this.$scope.searchText)
			,sSearchCol:$.trim(this.$scope.searchBy)
			,iDisplayStart:this.$scope.pageIdx * this.$scope.rowsPerPage
			,iDisplayLength:this.$scope.rowsPerPage
			,sColumns:this.columnNames.join(',')
			,iSortingCols:0
		};
		for (var i = 0; i < this.$scope.sorts.length; i++) {
			var k = this.columnNames.indexOf(this.$scope.sorts[i].attr);
			if (k >= 0) {
				paramsMap['iSortCol_'+paramsMap.iSortingCols] = k;
				paramsMap['sSortDir_'+paramsMap.iSortingCols] = (this.$scope.sorts[i].dir < 0) ? 'desc' : 'asc';
				paramsMap.iSortingCols++;
			}
		}

		for (var key in this.extraQueryParams) {
			paramsMap[key] = this.extraQueryParams[key];
		}

		url = this.baseURL+this.rowFetcher.buildQueryStringFromMap(paramsMap);

		if (this.modifyURLCallback !== null) {
			url = this.modifyURLCallback(this, url);
		}

		if (typeof fixupAJAXURL == 'function') {
			url = fixupAJAXURL(url);
		}
		var result = this.rowFetcher.getRowArrayForURL(url);
		var rows = [];
		for (var i = 0; i < result.aaData.length; i++) {
			var row = {};
			for (var j = 0; j < this.columnNames.length; j++) {
				row[this.columnNames[j]] = result.aaData[i][j];
			}
			rows.push(row);
		}
		this.$scope.clearContents(false);
		if (!this.$scope.$$phase) this.$scope.$apply();
		for (var i = 0; i < rows.length; i++) {
			this.$scope.addRow(rows[i], false);
		}
		this.$scope.highlightedRowIdx = (this.enableKeyboardNavigation && (this.$scope.rows.length > 0)) ? 0 : -1;
		this.$scope.externalPager_numPages = Math.max(1, Math.ceil(result.iTotalRecords/this.$scope.rowsPerPage));
		if (!this.$scope.$$phase) this.$scope.$apply();

		if (this.enableKeyboardNavigation) {
			// If keyboard navigation is enabled, then also enable mouse click for highlighting rows.
			var grid = this, cont = container;
			var tds = $('table.jax-grid-table tbody tr td', cont);
			tds.click(function(evt) {
				if (tds.is(evt.target)) { // only handle events whose targets are the TD elements in the grid's table body
					var rowIdx = $('table.jax-grid-table tbody tr', cont).index(evt.target.parentElement);
					if (rowIdx >= 0) {
						if (grid.$scope.highlightedRowIdx != rowIdx) {
							grid.$scope.highlightedRowIdx = rowIdx;
							if (!grid.$scope.$$phase) grid.$scope.$apply();
						}
					}
					evt.stopPropagation();
					evt.preventDefault();
					// Keep the focus on the search input.  Otherwise, arrow navigation may not work.
					$('input.jax-grid-pager-search-text-input:first', cont).focus();
				}
			});
			tds.dblclick(function(evt) {
				if (tds.is(evt.target)) { // only handle events whose targets are the TD elements in the grid's table body
					var rowIdx = $('table.jax-grid-table tbody tr', cont).index(evt.target.parentElement);
					if (rowIdx >= 0) {
						if (grid.$scope.highlightedRowIdx == rowIdx) {
							// Trigger a keydown event.  If we have a search box, make that the target, otherwise the container.
							var elem = $('input.jax-grid-pager-search-text-input:first', cont);
							if (elem.length == 0) elem = cont;
							var kevt = jQuery.Event('keydown');
							kevt.which = 13;
							kevt.altKey = false;
							kevt.ctrlKey = false;
							kevt.shiftKey = false;
							kevt.metaKey = false;
							elem.trigger(kevt);
						}
					}
					evt.stopPropagation();
					evt.preventDefault();
					// Keep the focus on the search input.  Otherwise, arrow navigation may not work.
					$('input.jax-grid-pager-search-text-input:first', cont).focus();
				}
			});
		}

		// Keep the focus on the search input.  Otherwise, arrow navigation may not work.
		$('input.jax-grid-pager-search-text-input:first', container).focus();

		this.$scope.searchEndDate = new Date();
		if (this.afterSearchCallback !== null) {
			this.afterSearchCallback(this);
		}
	}

	this.revertToDefaultSorts();

	// Begin a new scope for the keydown handler.
	{
		var grid = this;
		$('.jax-grid-pager-search-text-input', container).keydown(function(evt) {
			// Handle keyboard navigation, if enabled.
			if (grid.enableKeyboardNavigation) {
				switch (evt.which) {
				case 38: // Up arrow
					if (evt.altKey || evt.ctrlKey || evt.shiftKey || evt.metaKey) break;
					evt.stopPropagation();
					evt.preventDefault();
					if (grid.$scope.rows.length <= 0) break;
					grid.$scope.highlightedRowIdx--;
					if (grid.$scope.highlightedRowIdx < 0) grid.$scope.highlightedRowIdx = grid.$scope.rows.length-1;
					if (!grid.$scope.$$phase) grid.$scope.$apply();
					break;
				case 40: // Down arrow
					if (evt.altKey || evt.ctrlKey || evt.shiftKey || evt.metaKey) break;
					evt.stopPropagation();
					evt.preventDefault();
					if (grid.$scope.rows.length <= 0) break;
					grid.$scope.highlightedRowIdx++;
					if (grid.$scope.highlightedRowIdx >= grid.$scope.rows.length) grid.$scope.highlightedRowIdx = 0;
					if (!grid.$scope.$$phase) grid.$scope.$apply();
					break;
				case 33: // PageUp
					if (evt.altKey || evt.ctrlKey || evt.shiftKey || evt.metaKey) break;
					evt.stopPropagation();
					evt.preventDefault();
					var np = grid.$scope.getNumPages();
					if (np <= 0) break;
					if (grid.$scope.pageIdx > 0) {
						grid.$scope.setPageIdx(grid.$scope.pageIdx-1);
						if (!grid.$scope.$$phase) grid.$scope.$apply();
					}
					break;
				case 34: // PageDown
					if (evt.altKey || evt.ctrlKey || evt.shiftKey || evt.metaKey) break;
					evt.stopPropagation();
					evt.preventDefault();
					var np = grid.$scope.getNumPages();
					if (np <= 0) break;
					if ((grid.$scope.pageIdx+1) < np) {
						grid.$scope.setPageIdx(grid.$scope.pageIdx+1);
						if (!grid.$scope.$$phase) grid.$scope.$apply();
					}
					break;
				case 36: // Home
					if (evt.altKey || evt.ctrlKey || evt.shiftKey || evt.metaKey) break;
					evt.stopPropagation();
					evt.preventDefault();
					var np = grid.$scope.getNumPages();
					if (np <= 0) break;
					if (grid.$scope.pageIdx > 0) {
						grid.$scope.setPageIdx(0);
						if (!grid.$scope.$$phase) grid.$scope.$apply();
					}
					break;
				case 35: // End
					if (evt.altKey || evt.ctrlKey || evt.shiftKey || evt.metaKey) break;
					evt.stopPropagation();
					evt.preventDefault();
					var np = grid.$scope.getNumPages();
					if (np <= 0) break;
					if (grid.$scope.pageIdx < (np-1)) {
						grid.$scope.setPageIdx(np-1);
						if (!grid.$scope.$$phase) grid.$scope.$apply();
					}
					break;
				} // switch (evt.which)
			} // if (grid.enableKeyboardNavigation)

			// Handle hot keys and callbacks.
			for (var i = 0; i < grid.hotKeyActionMap.length; i++) {
				var o = grid.hotKeyActionMap[i];
				if (typeof(o) != 'object') continue;
				if ((typeof(o.which) == 'undefined') || (o.which != evt.which) || (typeof(o.callback) != 'function')) continue;
				if (((typeof(o.altKey) != 'undefined') ? o.altKey : false) != evt.altKey) continue;
				if (((typeof(o.ctrlKey) != 'undefined') ? o.ctrlKey : false) != evt.ctrlKey) continue;
				if (((typeof(o.shiftKey) != 'undefined') ? o.shiftKey : false) != evt.shiftKey) continue;
				if (((typeof(o.metaKey) != 'undefined') ? o.metaKey : false) != evt.metaKey) continue;
				o.callback(grid, evt);
				if (!evt.isPropagationStopped()) evt.stopPropagation();
				if (!evt.isDefaultPrevented()) evt.preventDefault();
			}
		});
	}

	this.$scope.getAJAXSearchGridRowClasses = function(rowIdx) {
		var classes = '', sep = '';

		if (rowIdx == this.$scope.highlightedRowIdx) {
			classes += sep+'highlighted';
			if (sep == '') sep = ' ';
		}

		return classes;
	}

	if (!this.$scope.$$phase) this.$scope.$apply();
}

AJAXSearchGrid.prototype.revertToDefaultSorts = function() {
	this.$scope.sorts = [];
	for (var i = 0; i < this.defaultSorts.length; i++) {
		var sort = this.defaultSorts[i];
		this.$scope.sorts.push({
			attr:sort.attr,
			dir:sort.dir
		});
	}
}
