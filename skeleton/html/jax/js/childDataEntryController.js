// DO NOT EDIT THIS FILE.
// This file is part of the Jax Framework.
// If you edit this file, your changes will be lost when framework updates are applied.

// Copyright (c) 2010-2012 Ronald B. Cemer
// All rights reserved.
// This software is released under the BSD license.
// Please see the accompanying LICENSE.txt for details.

// This class requires the inclusion of the dataTablesSupport.js include file if the dataTableContainer
// parameter is specified.

// Construct a new ChildDataEntryController instance.
// Parameters:
//   params: An associative array of parameter names to parameter values.  The following
//      parameter names are recognized:
//       dataTableContainer: An optional jQuery collection containing the parent container to which the
//            dataTable HTML will be appended as a child.  If the HTML table for the dataTable is created
//            externally, this parameter must be omitted in order to prevent the existing dataTable from
//            being overwritten.
//            This class requires the inclusion of the dataTablesSupport.js include file if the
//            dataTableContainer parameter is specified.
//       tableId: A unique HTML identifier for the HTML table element for the dataTable.  Must be unique
//            within the current HTML document.  If not specified, defaults to 'childTable'.
//       aoColumnDefs (array): The datatable's column definitions.
//       dataTableCreateParams (array): An associative array containing any extra parameters to be passed
//            to the dataTable constructor.  If specified, this will be merged with the default parameters.
//       blankRow (object): An associative array of value names to their values for a blank row.
//            This must include one value for each attribute of a row.
//       editingRowIdxChangeCallback (function): An optional function to be called when we change the row index
//            which is being edited.  This function receives one argument: the ChildDataEntryController instance.
function ChildDataEntryController(params) {
	this.dataTableContainer = (typeof(params.dataTableContainer) == 'object') ? params.dataTableContainer : null;
	this.tableId = (typeof(params.tableId) == 'string') ? params.tableId : 'childTable';
	this.aoColumnDefs = (typeof(params.aoColumnDefs) == 'object') ? params.aoColumnDefs : [];
	this.dataTableCreateParams = (typeof(params.dataTableCreateParams) == 'object') ? params.dataTableCreateParams : {};
	this.blankRow = (typeof(params.blankRow) == 'object') ? params.blankRow : {};
	this.editingRowIdxChangeCallback = (typeof(params.editingRowIdxChangeCallback) == 'function') ? params.editingRowIdxChangeCallback : null;

	this.rows = [];

	if (this.dataTableContainer !== null) {
		$(getDataTableHTML(this.tableId, this.aoColumnDefs)).appendTo(this.dataTableContainer);
	}
	this.dataTable = $('#'+this.tableId).dataTable($.extend(
		{
			aoColumnDefs: this.aoColumnDefs,
			aaData: this.rows,
			bFilter: false,
			bSort: false,
			sPaginationType: 'full_numbers'
		},
		this.dataTableCreateParams
	));

	// For Firefox, we have to insert another break before the table when bFilter is off.
	// If we don't, the table positions itself to the right of the container which holds
	// the entries-per-page select and its labels, which completely messes up the layout.
	if ($.browser.mozilla) {
		$('<br/>').insertBefore($('#'+this.tableId));
	}

	// Force the container which holds entries-per-page select and its labels to fill
	// the entire width, and align its text to the left.
	$('#'+this.tableId+'_length').css('width', '100%').css('text-align', 'left');

	this.editingRowIdx = -1;
	this.prevEditingRowIdx = -1;
}

// Clear the rows and the datatable.
// Parameters:
//    redraw: A boolean which determines whether to redraw the datatable (defaults to true if omitted).
ChildDataEntryController.prototype.clear = function(redraw) {
	if (typeof(redraw) == 'undefined') redraw = true;
	this.rows = [];
	this.dataTable.fnClearTable(redraw);
}

// Add a row into the rows array and the datatable.
// Parameters:
//    rowData: An associative array of value names to values for the known attributes of the row.
//        Any missing attributes will be filled in from the blankRow template.
// Returns the new element in the rows array.
ChildDataEntryController.prototype.addRow = function(rowData) {
	return this.addOrReplaceRow(rowData, this.rows.length);
}

// Replace a row into the rows array and the datatable.
// Parameters:
//    rowData: An associative array of value names to values for the known attributes of the row.
//        Any missing attributes will be filled in from the blankRow template.
//    rowIdx: The row index.
//        If a value < 0 or >= the number of existing rows is specified, this function will
//        return null without doing anything.
// Returns the updated element in the rows array.
ChildDataEntryController.prototype.replaceRow = function(rowData, rowIdx) {
	if ((rowIdx < 0) || (rowData >= this.rows.length)) return null;
	return this.addOrReplaceRow(rowData, rowIdx);
}

// Add or replace a row into the rows array and the datatable.
// Parameters:
//    rowData: An associative array of value names to values for the known attributes of the row.
//        Any missing attributes will be filled in from the blankRow template.
//    rowIdx: An optional row index.  This should only be specified when replacing an existing row.
//        If not specified, or >= the current number of rows, a new row will be appended.
//        If a value < 0 is specified, this function will return null without doing anything.
// Returns the new or updated element in the rows array.
ChildDataEntryController.prototype.addOrReplaceRow = function(rowData, rowIdx) {
	var replacingRow = false;
	if (typeof(rowIdx) == 'undefined') {
		rowIdx = this.rows.length;
	} else {
		if (rowIdx < 0) return null;
		if (rowIdx >= this.rows.length) {
			rowIdx = this.rows.length;
		} else {
			replacingRow = true;
		}
	}

	this.rows[rowIdx] = $.extend({}, this.blankRow, rowData);

	this.updateRowView(rowIdx);

	return this.rows[rowIdx];
}

// Insert a row into the rows array and the datatable.
// Parameters:
//    rowData: An associative array of value names to values for the known attributes of the row.
//        Any missing attributes will be filled in from the blankRow template.
//    rowIdx: The row index.  All rows at this index and greater will be shifted to the next
//        higher index in order to make room for the newly inserted row.
//        If not specified, or >= the current number of rows, a new row will be appended.
//        If a value < 0 is specified, this function will return null without doing anything.
ChildDataEntryController.prototype.insertRow = function(rowData, rowIdx) {
	var save_editingRowIdx = -1;
	if (this.editingRowIdx >= rowIdx) {
		save_editingRowIdx = this.editingRowIdx+1;
		this.editRow(-1);
	}

	var result = null;
	if (rowIdx >= this.rows.length) {
		rowIdx = this.rows.length;
		result = this.addRow(rowData);
	} else {
		// Add a blank row at the end.
		this.addRow({});
		// Shift everything down.
		for (var ri = this.rows.length-1; ri > rowIdx; ri--) {
			this.rows[ri] = this.rows[ri-1];
			this.updateRowView(ri);
		}
		result = this.replaceRow(rowData, rowIdx);
	}

	if (save_editingRowIdx >= 0) this.editRow(save_editingRowIdx);

	return result;
}

// Delete a row.
// Parameters:
//    rowIdx: The row index.
ChildDataEntryController.prototype.deleteRow = function(rowIdx) {
	if ((rowIdx < 0) || (rowIdx >= this.rows.length)) return false;

	var save_editingRowIdx = -1;
	if (this.editingRowIdx >= rowIdx) {
		if (this.editingRowIdx > rowIdx) save_editingRowIdx = this.editingRowIdx-1;
		this.editRow(-1);
	}

	// Shift data down.
	for (var ri = rowIdx; (ri+1) < this.rows.length; ri++) {
		this.rows[ri] = this.rows[ri+1];
		this.updateRowView(ri);
	}

	// Delete last rows element.
	this.rows.pop();

	// Delete last datatable row.
	this.dataTable.fnDeleteRow(this.rows.length);

	if (save_editingRowIdx >= 0) this.editRow(save_editingRowIdx);

	return true;
}

// Update a row's view.
// Parameters:
//    rowIdx: The row index.
//    redraw: true to redraw the row's HTML view, or false to just update the datatable's internals.
//         Optional.  Defaults to true.
ChildDataEntryController.prototype.updateRowView = function(rowIdx, redraw) {
	if ((rowIdx < 0) || (rowIdx >= this.rows.length)) return;
	if (typeof(redraw) == 'undefined') redraw = true;

	// Don't redraw the row which we're currently editing; that would wipe out our entry fields.
	if (rowIdx == this.editingRowIdx) redraw = false;

	var ndrows = this.dataTable.fnSettings().fnRecordsTotal();
	if (ndrows <= rowIdx) {
		for (; ndrows <= rowIdx; ndrows++) {
			this.dataTable.fnAddData(this.rows[ndrows], redraw);
		}
	} else {
		this.dataTable.fnUpdate(this.rows[rowIdx], rowIdx, 0, redraw, redraw);
	}
}

// Update all rows' views.
// Parameters:
//    redraw: true to redraw the row's HTML view, or false to just update the datatable's internals.
//         Optional.  Defaults to true.
ChildDataEntryController.prototype.updateAllRowViews = function(redraw) {
	if (typeof(redraw) == 'undefined') redraw = true;
	for (var ri = 0; ri < this.rows.length; ri++) this.updateRowView(ri, redraw);
	if (redraw) this.dataTable.fnDraw(true);
}

// Edit a row.
// Parameters:
//    rowIdx: The row index.  If this is < 0 or >= the number of existing rows,
//        no row will be edited and any existing editing will be stopped.
ChildDataEntryController.prototype.editRow = function(rowIdx) {
	if ((rowIdx < 0) || (rowIdx >= this.rows.length)) rowIdx = -1;
	var result = (rowIdx >= 0) ? true : false;

	if (rowIdx != this.editingRowIdx) {
		this.prevEditingRowIdx = this.editingRowIdx;
		this.editingRowIdx = rowIdx;
		if (this.prevEditingRowIdx >= 0) {
			// Re-draw previous editing row with non-editable view.
			this.updateRowView(this.prevEditingRowIdx, true);
		}
		if (this.editingRowIdx >= 0) {
			// If we begin editing a row which is not on the currently visible page in the
			// DataTable component, switch the visible page to the page on which the row
			// is located which we're about to edit.
			var settings = this.dataTable.fnSettings();
			var pn = Math.floor(this.editingRowIdx/settings._iDisplayLength);
			var ds = pn*settings._iDisplayLength;
			if (settings._iDisplayStart != ds) {
				this.dataTable.fnPageChange(pn);
			}
			// Re-draw current editing row with editable view.
			this.updateRowView(this.editingRowIdx, true);
		}
		if (this.editingRowIdxChangeCallback !== null) {
			this.editingRowIdxChangeCallback(this);
		}
	}
	return result;
}

// Given a row index, get the visible table row index, considering the page size and
// currently displayed page in the datatable.
// Parameters:
//    rowIdx: The row index.
// Returns:
//    The current visible row index within the HTML table, or -1 if the specified row
//    is not currently visible.
ChildDataEntryController.prototype.getVisibleTableRowIdxForDataRowIdx = function(rowIdx) {
	var settings = this.dataTable.fnSettings();
	if ((rowIdx < settings._iDisplayStart) ||
		(rowIdx >= (settings._iDisplayStart+settings._iDisplayLength))) {
		return -1;
	}
	return rowIdx-settings._iDisplayStart;
}
